---
layout: post
title: StructureMap and Deep Inheritance at Runtime
date: 2016-05-31 23:21:44.000000000 -05:00
type: post
published: true
status: publish
categories: []
tags: []
meta: {}
author:
  login: brycekbargar@gmail.com
  email: brycekbargar@gmail.com
  display_name: Bryce Bargar
  first_name: Bryce
  last_name: Bargar
---
<p>(I realized this post is hard to read after posting, but I'm in the middle of migrating to Jekyll from Squarespace and it will be readable there in a few short days...)</p>
<p>Two posts in one day?! It's amazing what you can do accomplish you've disabled your twitter...</p>
<p>I had an issue at work today with StructureMap that I wanted to write up in case it helps someone.<br />I love StructureMap and have been using it for 4 years now, at 3 different companies.<br />Unfortunately right now I'm on V2.3.1, so the solution may be different on newer versions.</p>
<p>TLDR; I had multiple levels of Inheritance and StructureMap couldn't resolve them dynamically at runtime using Default Conventions.</p>
<h2 id="the-setup">The setup</h2>
<pre><code class="lang-csharp">public interface IView { }

public interface IPresenter { }
public interface IPresenter&lt;TView&gt; where TView : IView { }

public abstract class PresenterBase&lt;TView&gt; 
  : IPresenter&lt;TView&gt; 
  where TView : IView
{
  protected PresenterBase(TView view) { }
}</code></pre>
<p>Here is the basic plumbing of an <a href="http://codebetter.com/jeremymiller/2007/07/26/the-build-your-own-cab-series-table-of-contents/">MVP</a> application.<br />The same sort of problem could appear in any sufficiently large c# app,<br />but MVP (yes winforms...) is what I use at work and where this problem came up.</p>
<p>So my boss slacks me this morning.</p>
<blockquote>
<p>"We've seen an uptick in Alien Invasions and need a way to track them, think you could whip something up?"</p>
</blockquote>
<p>Easy! Let's just set up our form and make sure StructureMap can wire everything up!</p>
<pre><code class="lang-csharp">public interface IAlienInvasionView : IView { }

public interface IAlienInvasionPresenter : IPresenter&lt;IAlienInvasionView&gt; { }
public class AlienInvasionPresenter
  : PresenterBase&lt;IAlienInvasionView&gt;, IAlienInvasionPresenter
{
  public AlienInvasionPresenter(AlienInvasionView view) : base(view) { }
}</code></pre>
<p>Now let's setup StructureMap like a good girl who can read docs</p>
<pre><code class="lang-csharp">public class UserInterfaceRegistry : Registry
{
  public UserInterfaceRegistry()
  {
    Scan(scan =&gt; 
    {
      scan.TheCallingAssembly();
      scan.WithDefaultConventions();

      /* 
       * + 15 lines of legacy StructureMap hacks :(
      */
    });
  }
}</code></pre>
<p>And grab a presenter to start recording all the important invasion details!</p>
<pre><code class="lang-csharp">var presenter = ObjectFactory.TryGetInstance(typeof(IAlienInvasionPresenter));</code></pre>
<p>I <code>git commit; git push</code> and go to lunch confident invasion details can now be tracked.<br />Upon returning to my desk, I see a slack from my boss.</p>
<blockquote>
<p>"There's been a bird Invasion! Quick! We need to make a new form for capturing the details!"</p>
</blockquote>
<p>Hmmm...<br />Well, we already have an Alien Invasion form and Bird Invasion are surprisingly similar.<br />This seems like a great case for (the probably overused) inheritance!</p>
<p>So let's set it up.</p>
<pre><code class="lang-csharp">public interface IInvader { }
public class Alien : IInvader { }
public class Bird : IInvader { }

public interface IGenericInvasionPresenter : IPresenter { }
public interface IGenericInvasionPresenter&lt;TInvader&gt; 
  : IGenericInvasionPresenter 
  where TInvader : IInvader
{
}

public abstract class GenericInvasionPresenterBase&lt;TInvader, TView&gt; 
  : GenericPresenter&lt;TView&gt;, IGenericInvasionPresenter&lt;TInvader&gt;
  where TInvader : IInvader 
  where TView : IView
{
  protected GenericInvasionPresenterBase(TView view) : base(view) { }
}</code></pre>
<p>Nothing too scary.<br />We're making a common interface for interacting with the presenter<br />and a base implementation to hold the 90% of shared behavior.</p>
<p>Let's put the Alien Invasion specific code into its own presenter.</p>
<pre><code class="lang-csharp">public class AlienInvasionPresenter
  : GenericInvasionPresenterBase&lt;Alien, AlienInvasionView&gt;
{
  public AlienInvasionPresenter(IAlienInvasionView view) : base(view) { }
}</code></pre>
<p>Notice here that the AlienInvasionPresenter is implementing/inheriting</p>
<ul>
<li><code>IPresenter</code></li>
<li><code>IPresenter&lt;AlienInvasionView&gt;</code></li>
<li><code>IGenericInvasionPresenter</code></li>
<li><code>IGenericInvasionPresenter&lt;Alien&gt;</code></li>
<li><code>PresenterBase&lt;AlienInvasionView&gt;</code> // kind of a lie since c# has single inheritance, but it's in the tree somewhere</li>
<li><code>GenericInvasionPresenterBase&lt;Alien, AlienInvasionView&gt;</code></li>
</ul>
<p><em>this next part is a little contrived, but bear with me...</em><br />Since we won't know until Invasion time weather we're dealing with Aliens or Birds<br />we have to dynamically create a presenter at runtime.</p>
<p>Like any good .NET Witch I'll use a factory method.</p>
<pre><code class="lang-csharp">public static IGenericInvasionPresenter GetInvasionPresenterFor(Type invaderType)
{
  var presenterType = typeof (IGenericInvasionPresenter&lt;&gt;).MakeGenericType(invaderType);
  var presenter = ObjectFactory.TryGetInstance(presenterType);
  return presenter as IGenericInvasionPresenter;
}</code></pre>
<p>Yay! <code>git commit; git push</code> Who needs to test their code?<br />Well actually...</p>
<h2 id="the-problem">The Problem</h2>
<p><code>AlienInvasionPresenter</code> now longer follows the default <code>IFoo</code> -&gt; <code>Foo</code> naming conventions.<br /><code>ObjectFactory.TryGetInstance()</code> now returns <code>null</code> for the presenter and <code>NullReferenceException</code>s make me very sad...</p>
<p>I'm usually pretty good at following conventions so it's rare that I have to drop into the more esoteric container options.<br />First I unsuccessfully tried my usual fix of <code>scan.ConnectImplementationsToTypesClosing(typeof(IGenericInvasionPresenter&lt;&gt;));</code><br />The most promising StackOverflow fix of <code>scan.AddAllTypesOf(typeOf(GenericInvasionPresenterBase&lt;,&gt;));</code> didn't seem to work either.<br />After many more hacks and an hour of doc reading StructureMap still seemed incapable of resolving the presenter...</p>
<p>This is the point where I usually give up and change my code so it's slightly less elegant but doesn't require black magic configuration.<br />But not this time! My code was so elegant I couldn't give it up!<br />(plus who actually likes writing code like <code>For&lt;IGenericInvasionPresenter&lt;Alien&gt;().Use&lt;AlienInvasionPresenter&gt;()</code>?)<br />(plus I anticipated many more invasion types and wanted new ones to <em>just work</em>)</p>
<h2 id="the-solution">The Solution</h2>
<p>So I did the rookie dev thing and wrote a custom IRegistrationConvention.<br />(apologies to future devs who get ambushed by the non-standard behavior...)</p>
<p>Here's the custom convention in all it's v2.3.1 glory.</p>
<pre><code class="lang-csharp">public class InvasionPresenterRegistrationConvention : IRegistrationConvention
{
  private static readonly Type InvasionPresenter = typeof(IGenericInvasionPresenter);
  private static readonly Type InvasionPresenterOpen = typeof(IGenericInvasionPresenter&lt;&gt;);
  private static readonly Type Invader = typeof(IInvader);

  // I think this signature has been changed in newer versions
  public void Process(Type type, Registry registry)
  {
    // We only want to inspect our Once and Future InvasionPresenters
    if (type.IsClass 
      &amp;&amp; type.IsAbstract == false 
      &amp;&amp; InvasionPresenter.IsAssignableFrom(type))
    {
      Type baseType;
      if ((baseType = type.BaseType) == null
        || baseType != typeof(object))
      {
        // Exceptions during initialization?! 
        // I want to make sure any future devs follow the pattern for the AutoMagic
        // Either that or they explicitly make informed changes to this code
        throw new InvalidOperationException($"If {type} is an InvasionPresenter it must inherit from GenericInvasionPresenterBase!");
      }

      var invaderType =
        baseType
          .GetInterfaces() // IGenericInvasionPresenter&lt;&gt;, IGenericInvasionPresenter, IPresenter&lt;&gt;, IPresenter
          .Where(t =&gt; t.IsConstructedGenericType) // IGenericInvasionPresenter&lt;&gt;, IPresenter&lt;&gt;
          .Where(t =&gt; t.GenericTypeArguments.Length == 1) // Let's just be safe?
          .Select(t =&gt; t.GenericTypeArguments[0])
          .SingleOrDefault(t =&gt; Invader.IsAssignableFrom(t)); // This should give us the IInvader we care about

      if (invaderType == null)
      {
        throw new InvalidOperationException($"{type} has no IInvader type parameter!");
      }

      // Looks like our factory!
      var presenterType = InvasionPresenterOpen.MakeGenericType(invaderType);
      // Looks like StructureMap!
      registry.For(presenterType).Use(type);
    }
  }
}</code></pre>
